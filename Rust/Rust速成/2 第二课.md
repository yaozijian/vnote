# 第二课

* 每个值有一个所有者变量
* 每个值任何时刻只能有一个所有者变量
* 所有者变量离开作用域时，值被释放（通过调用其`Drop`特性的`drop()`方法）

## 1 简单示例

```rust
#[derive(Debug)]
struct Foobar(i32);

fn uses_foobar(foobar: Foobar) {
    println!("I consumed a Foobar: {:?}", foobar);
}

fn main() {
    let x = Foobar(1);
    // 调用函数时 x 的所有权被转移, x 失效
    uses_foobar(x);
    // 这里再使用 x 是错误的，会出错编译错误
    uses_foobar(x);
}
```

## 2 释放

```rust
#[derive(Debug)]
struct Foobar(i32);

// 所有者变量离开作用域时，其Drop特性的drop方法被调用
impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn uses_foobar(foobar: Foobar) {
    println!("I consumed a Foobar: {:?}", foobar);
}

fn main() {
    let x = Foobar(1);
    println!("Before uses_foobar");
    uses_foobar(x);
    println!("After uses_foobar");
}
```

## 3 词法作用域

```rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn main() {
    println!("Before x");
    let _x = Foobar(1);
    println!("After x");
    {
        println!("Before y");
        let _y = Foobar(2);
        println!("After y");
        // _y 离开作用域,被释放
    }
    println!("End of main");
    // _x 离开作用域,被释放
}
```

## 4 借用

### 4.1 不可变借用

```rust
#[derive(Debug)]
struct Foobar(i32);

impl Drop for Foobar {
    fn drop(&mut self) {
        println!("Dropping a Foobar: {:?}", self);
    }
}

fn uses_foobar(foobar: &Foobar) {
    println!("I consumed a Foobar: {:?}", foobar);
}

fn main() {
    let x = Foobar(1);
    println!("Before uses_foobar");
    // 所有权没有转移,可以多次借用
    uses_foobar(&x);
    uses_foobar(&x);
    println!("After uses_foobar");
}
```

### 4.2 多个借用

```rust
fn main() {
    let x: Foobar = Foobar(1);
    let y: &Foobar = &x;
    println!("Before uses_foobar");
    // 两个借用: 1 都是不可变借用,没有数据竞争 2 x 的作用域比两个借用(&x和y)的作用域都长
    uses_foobar(&x);
    uses_foobar(y);
    println!("After uses_foobar");
}
```

### 4.3 引用比值的生命周期长

```rust
fn main() {
    let x: Foobar = Foobar(1);
    let y: &Foobar = &x;
    println!("Before uses_foobar");
    uses_foobar(&x);
    // 无法移动 x 的所有权,因为存在对 x 的引用
    // 对 x 的借用 y 的生命周期比 x 长,这是不允许的,会导致编译错误
    std::mem::drop(x);
    uses_foobar(y);
    println!("After uses_foobar");
}
```

### 4.4 可变引用与其他引用互斥

* 只能对可变变量进行可变引用

```rust
fn main() {
    let mut x: Foobar = Foobar(1);
    let y: &mut Foobar = &mut x;
    println!("Before uses_foobar");
    // 编译错误：存在可变引用的时候，不能再进行不可变引用
    uses_foobar(&x);
    uses_foobar(y);
    println!("After uses_foobar");
}
```

### 4.5 变成可变的

* 可变性是变量（绑定）的特征，而不是值的特征；移动值时可以改变可变性

```rust
#[derive(Debug)]
struct Foobar(i32);

fn main() {
    let x = Foobar(1);
    // x 的值被移动,main函数中x无效,管不着其是否可变
    foo(x);
}

fn foo(mut x: Foobar) {
    x.0 = 2;
    println!("{:?}", x);
}
```

## 5 `Copy`特性

* 实现了`Copy`特性，则对变量进行赋值、作为参数传递、作为返回值返回时，调用`Copy`进行值的赋值，而不是转移所有权

```rust
#[derive(Debug,Clone,Copy)]
struct Foobar(i32);

fn uses_foobar(foobar: Foobar) {
    println!("I consumed a Foobar: {:?}", foobar);
}

fn main() {
    let x = Foobar(1);
    uses_foobar(x);
    uses_foobar(x);
}
```

## 6 生命周期

