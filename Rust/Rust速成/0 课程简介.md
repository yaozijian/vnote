# 0 课程简介

## 1 可变的值、可变的变量

### 示例1：所有权类型可以从不可变变成可变

* 不可变的`i`为什么可以传递给`foo`（要求可变的参数）作为参数？
* 原因不是类型`isize`实现了`Copy`，因为用没有实现`Copy`的`String`也可以（见示例2）

```rust
fn main() {
    let i: isize = 1;
    let j: isize = foo(i);
    println!("{}", j);
}

fn foo(mut i: isize) -> isize {
    i += 1;
    i
}
```

### 示例2：所有权类型可以从不可变变成可变，与`Copy`特性无关

* 下面的示例也是正确的
* 正确的解释是：参数使用所有权类型，<font color="red">**对于所有权类型，可以改变绑定类型（可变/不可变）**</font>

```rust
fn main() {
    let i = String::from("a");
    let j = foo(i);
    println!("{}", j);
}

fn foo(mut i: String) -> String {
    i.push_str("bc");
    i
}
```

### 示例3：引用类型只能从可变变成不可变，不能反过来

* 如果`foo`的参数是引用类型，则只能从可变变成不可变，而不能反过来

```rust
fn main() {
    let mut i = String::from("a");
    let j = foo(&mut i);
    println!("{}", j);
}

fn foo(i: &mut String) -> &String {
    i.push_str("bc");
    i
}
```

### 示例4：关于`mut`的总结

<font color="red">

* 只能对引用类型使用两个`mut`
* `mut i:&'a mut isize`中
  * 第一个`mut`表示绑定可变：可以将`i`指向别的资源：允许对`i`进行重新赋值
  * 第二个`mut`表示可修改指向的资源：可以对`*i`进行重新赋值；可以通过`i`调用类型的需要`&mut Self`参数的方法

</font>

```rust
fn main() {
    let mut i: isize = 1;
    let mut j: isize = 2;
    foo(&mut i, &mut j);
    println!("{} {}", i, j);
}

fn foo<'a>(mut i: &'a mut isize, j: &'a mut isize) {
    *i *= 10;
    i = j;
    *i *= 10;
}
```

## 2 多种字符串类型

```rust
fn main() {
    let hello1 = String::from("Hello, ");
    let hello2 = String::from(", hello!");
    let name = "Alice";
    println!("{}", hello1 + name);
    println!("{}", name + hello2);
}
```

* 上面的示例无法编译通过
  1. `hello1 + name`：对`+`的使用要求调用`std::ops::Add`特性的`add`方法，而`String::add`方法的参数要求`mut Self`类型，对于用于所有权的`hello1`，可以在调用方法时自动改变绑定类型
  2. `name + hello2`：不正确，`name`是不可变引用类型，无法调用要求所有权的`add`方法

## 3 魔法

* 作者举例不恰当，没有那么复杂的

```rust
fn main() {
    for arg in std::env::args().skip(1) {
        respond(arg.as_str());
    }
}

fn respond(arg: &str) {
    match arg {
        "hi" => println!("Hello there!"),
        "bye" => println!("OK, goodbye!"),
        _ => println!("Sorry, I don't know what {} means", arg),
    }
}
```

## 4 移动数据到闭包中

* 移动数据到闭包中，是最难掌握的

```rust
fn main() {
    let hello = String::from("Hello, ");
    // hello + name 要求调用 String::add() 方法，而这个方法的接收器是 mut Self 类型，要求所有权，所以 hello 会被移动到闭包中
    let greet = |name| hello + name;
    // 首次调用闭包,hello 被移动到闭包中
    println!("{}", greet("Alice"));
    // 二次调用闭包，无法将 已经被移动的 hello 移动到闭包中，编译出错
    println!("{}", greet("Bob"));
}
```
