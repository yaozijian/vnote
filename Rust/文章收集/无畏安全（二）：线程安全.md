# 无畏安全（二）：线程安全

* 很常见的并发带来了并发问题，包括死锁、数据竞争。
* 并发方面的bug，通常与程序的正确性有关。
* 顺序代码中，逻辑错误通常发生在错误代码附近；而并发方面的bug常出现在不同于违反了并发规则的函数中，使得bug难以跟踪和解决。

## 1 并发问题

* 死锁：多个线程都在相互等待其他线程执行某些动作以便继续，从而所有线程都被永久阻塞。
* 竞态条件：任务的时序或者次序会影响程序的正确性时，多个线程试图并发地访问相同的内存位置，并且其中至少有一个访问是写操作。
* 并发问题的后果
	* 死锁
	* 信息丢失：其他线程改写了信息
	* 完整性丢失：来自多个线程的信息相互交错
	* 及时性(liveness)丢失：对共享资源的不受限访问所导致的性能问题
* TOCTOU（time of check to time of use，检测时使用）是最知名的并发攻击，这是一种检查条件与使用结果之间的竞态条件，会导致完整性丢失。
* 死锁和及时性丢失被认为是性能问题，而不是安全问题；而信息和完整性丢失都是安全相关的。
* 并发编程中最需要技巧的部分是测试与调试：并发bug很难重现。		
	* 事件时序、操作系统决策、网络通信等都可以让有并发bug的程序每次运行时有不同的行为。
	* 插入输出或者调试语句也可能导致行为改变，让bug神秘地消失。

## 2 编程语言如何管理并发

并发编程很难：难以预测并发代码之间如何相互交互。bug出现时，很难找到错误的位置然后加以修复。编程语言应该让编写并发代码变得简单一些。

线程安全的定义：被多个线程使用时，不需要调用方代码执行额外的协调，无论多个线程如何执行，代码行为都是正确的，则数据类型或者静态方法是线程安全的。

不能静态保证线程安全的语言中，处理可以与其他线程共享、可能在任何时候被修改的内存时，程序员需要持续的心智负担。与手动内存管理类似，要求程序员安全地修改共享数据常常会出问题。

编程语言通常使用两种方法来实现安全的并发：

* 限制修改或者共享
* 手动线程安全管理（如锁、信号量）

限制可写变量到单个线程中，或者要求共享的变量是不可写的，都排除了数据竞争的核心问题--不正确地修改共享数据，但是这种限制太严格了。为解决这个问题，语言引入了互斥量之类的底层同步原语。

### 2.1 Python全局解释器锁

* Python的参考实现CPython，有一个全局解释器锁，仅仅允许单个线程访问Python对象。
* Python多线程性能差，因为需要等待获取全局解释器锁。
* 大部分并行Python程序使用多进程：每个进程有自己的全局解释器锁。

### 2.2 Java运行时异常

* Java通过共享内存模型来支持并发编程：每个线程有自己的执行路径，但是都可以访问程序中的任何对象，程序员需要使用内置的原语来同步多线程对对象的访问。
* Java有创建线程安全程序的机制，但是线程安全不是由编译器保证的。非同步的内存访问发生时，Java会抛出运行时异常：线程安全还是依赖于程序员正确地使用并发原语。

### 2.3 C++

* C++依赖程序员手动同步内存访问
* C++ 11之前，标准库不包含并发原语

## 3 Rust如何管理并发

Rust通过所有权规则和类型安全，在编译时就可以排除数据竞争。

### 3.1 转移所有权

* 每个变量有单个所有者，可以被移动或者借用。
* 如果其他线程需要修改一个资源，可以通过移动变量到新线程中的方法来转移所有权。
* 移动保证了独占：多个线程可以写入相同的内存，但是不能同时写入。

### 3.2 借用

所有者被限定到单个线程，但是如果其他线程借用了变量，又会如何？

* 变量可以有一个可变借用，或者多个不可变借用，但是不能同时有可变借用和不可变借用。这保证了在某个时刻，只有一个线程可以修改变量。

很多语言有保证内存安全的机制（引用计数、垃圾收集等），但通常依赖于手动同步，或者限制并发的共享来阻止数据竞争。Rust通过解决标识有效资源使用这个核心问题，在编译时就同时解决了内存安全和并发安全问题。

### 3.3 线程安全的数据结构

* Rust有两个重要的内置特性：Send和Sync，编译器会自动为每种可能的类型实现这两个特性：
	* Send：表示可以安全地在线程间发送类型实例（要求所有权转移）
	* Sync：表示可以安全地在线程间共享类型实例
* 这两个特性让类型系统知道哪些数据可以被共享，线程安全问题变成了类型安全问题。线程安全由编译器保证，不用程序员操心。
