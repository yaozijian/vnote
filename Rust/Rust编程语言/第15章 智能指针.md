
# 第十五章 智能指针

## 0 简介

* 引用：最常见的指针类型，不拥有资源的所有权
* 智能指针：一类表现类似指针的数据结构
  * 通常拥有资源的所有权
  * 通常实现了`Deref`和`Drop`特性
  * 常用的智能指针
      * `Box<T>` 用于在堆上分配值
      * `Rc<T>` 一个引用计数类型，其数据可以有多个所有者
      * `Ref<T>` `RefMut<T>` 和 `RefCell<T>`

## 1 `Box<T>`

`Box<T>`的用途如下：

* 在需要确定大小的上下文中使用大小未知类型（如递归类型），本节讨论这种情况
* 需要在不复制数据的情况下转移大量数据的所有权时。转移栈上数据的所有权将导致数据复制，对于大量数据 ，复制时间可能很长，这时候可以使用`Box<T>`：转移`Box<T>`的所有权只需要复制栈上的数据指针，而不需要复制堆上的数据，所以开销很小。
* 需要一个实现了特定trait的不确定类型时，这就是第17章将讨论的特性对象（trait object）

### 示例1：不使用`Box<T>`创建递归类型

* 下述代码无法通过编译，提示递归类型List具有无限大小，建议使用`box`、`Rc`或者`&`实现的间接引用
* 非递归的枚举类型的大小，等于最大字段的大小

```rust
enum List{
    Cons(i32,List),
    Nil,
}
fn main(){
   let list = Cons(1,Cons(2,Cons(3,Nil)));
}
```

### 示例2：使用`Box<T>`创建递归类型

* `Box<T>`提供了间接存储和堆分配，没有其他特殊功能，所以没有其他智能指针的额外开销
* `Box<T>`实现了`Deref`特性，所以是智能指针，可以被当做引用对待。
* 离开作用域时，`Box<T>`实现的`Drop`特性中的`drop`方法被调用，这个方法会清理堆上的数据（栈上的指针被自动清理）。

```rust
enum List{
    Cons(i32,Box<List>),
    Nil,
}
fn main(){
   let list = Cons(1,Box::new(Cons(2,Box::new(Cons(3,Box::new(Nil))))));
}
```

## 2 `Deref`特性

* 引用可看做是指针，可通过解引用运算符 `*` (星号)访问指针指向的值
* `Box<T>` 实现了`Deref`特性，可以被当做指针使用，即也可以对`Box<T>`类型使用解引用运算符

```rust
let x = 5;
let y = &x;
let z = Box::new(x);
assert_eq!(x,5);
assert_eq!(*y,5);
assert_eq!(*z,5);// 对Box<T>类型使用解引用运算符
```

### 2.1 实现`Deref`特性

* 自定义类型`MyBox<T>`实现`std::ops::Deref`特性后，就可以对其示例使用解引用运算符了
* 对实现了`std::ops::Deref`的类型实例使用解引用运算符时，实际上相当于`*(z.deref())`，所以`deref()`方法必须返回引用值：如果返回的不是引用值，则不能对其使用解引用运算符

```rust
struct MyBox<T>(T);

impl<T> MyBox<T>{
    fn new(x: T) -> MyBox<T>{
        MyBox(x)
    }
}

use std::ops::Deref;

impl<T> Deref for MyBox<T>{
    type Target = T;
    fn deref(&self) -> &T{
        &self.0
    }
}

fn main(){
    let x = 5;
    let y = &x;
    let z = MyBox::new(x);

    assert_eq!(x,5);
    assert_eq!(*y,5);
    assert_eq!(*z,5);
}
```

### 2.2 解引用强制多态(deref coercions)

* 传递函数/方法参数时，Rust会在必要时多次调用`Deref`特性的`deref`方法，使得传入的参数类型与函数/方法要求的类型一致，这就是<font color="red">**解引用强制多态(deref coercions)**</font>
* 解引用强制多态发生在编译时，没有运行时性能开销
* <font color="red">解引用强制多态规则</font>
  * 当`T: Deref<Target=U>`时从`&T`到`&U`
  * 当`T: DerefMut<Target=U>`时从`&mut T`到`&mut U`
  * 当`T: Deref<Target=U>`时从`&mut T`到`&U`

```rust
fn hello(x : &str){ println!("{}",x); };
let a = MyBox::new(String::from("ABC"));
hello(a.deref().deref());
hello(&a);
hello(&*a);
//下面两句是错误的
//hello(*a);
//hello(a);
```

## 3 `Drop`特性

### 3.1 实现`Drop`特性

```rust
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {// 注意签名: 要求&mut self
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer { data: String::from("my stuff") };
    let d = CustomSmartPointer { data: String::from("other stuff") };
    println!("CustomSmartPointers created.");
}
```

### 3.2 手动调用`Drop::drop()`方法

* 变量离开作用域时，`Drop::drop()`方法被自动调用，这个特性不能关闭
* 不能直接调用`Drop::drop()`方法
* 但可以调用`std::mem::drop()`函数，传入变量，实现间接调用`Drop::drop()`

## 4 `Rc<T>`：引用计数的智能指针

* 使用场景：单线程、多处只读使用、无法确定哪部分最后结束使用（然后释放资源）
  * 希望在堆上分配一些内存供程序的多个部分读取，但无法在编译时确定程序的哪一部分会最后结束使用
  * 如果知道哪部分会最后结束使用，则让这部分成为数据的所有者，让其离开作用域时释放数据就可以了；其他部分使用数据的不可变引用就可以了

### 4.1 不使用`Rc<T>`定义递归结构

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}
let a = List::Cons(5,Box::new(List::Cons(10,Box::new(List::Nil))));
let _b = List::Cons(3, Box::new(a));
//编译错误：上个语句将变量a的所有权移动到b中了,a已经失效
//let c = List::Cons(4, Box::new(a));
```

### 4.2 使用`Rc<T>`定义递归结构

`Rc::clone(&a)`的写法

* 下述代码中的`Rc::clone(&a)`也可以写成`a.clone()`，但是Rust中的习惯写法是`Rc::clone(&a)`
* `Rc::clone(&a)`强调了通过`Rc`进行克隆，只增加引用计数，而不进行深拷贝
* `a.clone()`这种写法通常用于深拷贝的情况
* `Rc::strong_count(&a)`获取引用计数、克隆会增加引用计数

```rust
use std::rc::Rc;

enum List {
    Cons(i32, Rc<List>),
    Nil,
}

let a = Rc::new(List::Cons(5,Rc::new(List::Cons(10,Rc::new(List::Nil)))));
println!("a的引用计数：{}",Rc::strong_count(&a));//1

let _b = List::Cons(3, Rc::clone(&a));
println!("a的引用计数：{}",Rc::strong_count(&a));//2

{
let _c = List::Cons(4, Rc::clone(&a));
println!("a的引用计数：{}",Rc::strong_count(&a));//3
}

println!("a的引用计数：{}",Rc::strong_count(&a));//2
```

### 4.3 `Rc<T>`的常用方法

* 所有固有方法都是关联方法（没有实例方法），调用时通常写作`Rc::get_mut(&mut value)`的形式，而不用`value.get_mut()`的形式，以避免与类型`T`的固有方法冲突
* `clone()`：克隆一份实例，实际上只是增加引用计数
* `strong_count()`：获取引用计数
* `weak_count()`：获取弱引用计数 
* `downgrade()`：获取弱引用，然后调用弱引用的`upgrade()`获取`Option<Rc<T>>`供使用
* `fn get_mut(this: &mut Rc<T>) -> Option<&mut T>`：如果当前没有其他引用和弱引用，则返回内部值的可变引用；否则返回`None`
* `fn make_mut(this: &mut Rc<T>) -> &mut T`：如果当前没有其他引用和弱引用，则返回内部值的可变引用；否则对内部值调用`clone()`方法，返回克隆出的值的可变引用，这就是`clone-on-write`

## 5 `RefCell<T>`与内部可变性

* 对于引用和`Box<T>`，编译时进行借用规则检查，检查不通过时发生编译错误。这是大多数情况下的合理选择，但过于保守，除了能检查出错误的程序外，有时候还会拒绝正确的程序。
* 对于`RefCell<T>`，程序运行时进行借用规则检查，检查不通过则发生`panic!`。`RefCell<T>`实现了<font color="red">内部可变性设计(interior mutability)模式</font>，允许通过不可变借用来修改数据（的某个字段）。
* 要点
  1. `use std::cell::RefCell`
  2. 声明：`sent_messages: RefCell<Vec<String>>`
  3. 创建：`sent_messages: RefCell::new(vec![])`
  4. 使用：`sent_messages.borrow_mut().push(String::from("abc"))`

* <font color="red">运行时进行借用规则检查：下述代码编译通过，但运行时试图获取第二个可变引用时触发`panic!`</font>

```rust
let mut one_borrow = self.sent_messages.borrow_mut();
let mut two_borrow = self.sent_messages.borrow_mut();
```

* 以下是示例代码片段

```rust
use std::cell::RefCell;

pub trait Messager {
    fn send(&self, msg: &str);
}

struct MockMessenger {
    sent_messages: RefCell<Vec<String>>,
    //sent_messages: Vec<String>,
}

impl MockMessenger {
    fn new() -> MockMessenger {
        MockMessenger { sent_messages: RefCell::new(vec![]) }
    }

    fn demo(&self) {
        let mut one_borrow = self.sent_messages.borrow_mut();
        // 编译通过，运行时进行借用规则检查，导致panic!：资源不能同时有两个可变引用
        let mut two_borrow = self.sent_messages.borrow_mut();

        one_borrow.push(String::from("abc"));
        two_borrow.push(String::from("123"));
    }
}

impl Messager for MockMessenger {
    fn send(&self, message: &str) {
        // 错误：没法通过不可变的self引用来取得self.sent_messages的可变引用(push方法要求可变引用)
        // self.sent_messages.push(String::from(message));
        // 借助RefCell的borrow_mut()方法，可通过不可变的self引用取得self.sent_messages的可变引用
        self.sent_messages.borrow_mut().push(String::from(message));
    }
}
```








